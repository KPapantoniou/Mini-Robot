# Physical Robot Controller

This project provides the software necessary to control a physical robot using camera-based visual feedback and UDP communication. It enables the robot to navigate to a user-defined target, offering both macro and micro-level control strategies.

### Features

* **Camera-Based Localization**: Utilizes OpenCV for real-time video processing to detect robot and target markers.
* **Two Control Modes**: Implements distinct "Macro" and "Micro" control strategies for navigation, suitable for different robot behaviors or environmental conditions.
* **UDP Communication**: Sends movement commands from the PC (controller) to an ESP32-based robot (firmware) over UDP.
* **Real-time Trajectory Plotting**: Python scripts visualize the robot's path and motor speeds in real-time.
* **Camera Calibration**: Includes a utility for calibrating the camera to convert pixel coordinates to real-world measurements (cm).
* **Video Recording**: Option to record the control session video for later analysis.
* **User Interaction**: Allows users to set a target by clicking on the video feed and control the robot with keyboard commands.
Note: the path for the trajectories output data and the videos are hardcoded for the system. You may want to modify the paths.
### Components

The project consists of two main parts: the PC-side controller (C++ application) and the ESP32 firmware.

#### PC-side Controller (C++)

* `main.cpp`: The primary application file that initializes the camera, sets up mouse callback for target selection, handles video capture and recording, and integrates the different robot controllers.
* `camera_calibrator.h`/`camera_calibrator.cpp`: Manages camera calibration to establish a pixel-to-centimeter ratio, crucial for accurate robot movement calculations.
* `udp_client.h`/`udp_client.cpp`: Handles the UDP client-side communication, sending commands to the ESP32.
* `robot_controller.h`/`robot_controller.cpp`: Abstract base class defining the interface for robot movement calculation and marker detection. Provides core functionalities like distance and angle calculation.
* `macro_controller.h`/`macro_controller.cpp`: Implements the "Macro" control strategy, likely for larger movements or reaching general areas, using color-based marker detection for the front and rear of the robot.
* `micro_controller.h`/`micro_controller.cpp`: Implements the "Micro" control strategy, potentially for fine-tuned adjustments or precise positioning, using marker detection and contour analysis to find the front tip.

#### ESP32 Firmware (Arduino/C++)

* `main_esp.cpp`: The firmware for the ESP32 micro-controller. It handles Wi-Fi connection, UDP server setup to receive commands from the PC, motor control (PWM), and PID control for maintaining motor speeds based on sensor feedback. It also sends debug information back to the PC.

#### Python Scripts

* `trajectory_plot.py`: A script to read `robot_path.csv` (generated by the C++ controller) and plot the robot's trajectory, X and Y positions over time, and Y vs X position.
* `commands_animation.py`: A script that acts as a keyboard interface to send UDP commands to the ESP32 and visualizes real-time motor RPMs (Motor A and B) received as debug logs from the ESP32.
* `parameters_pwm`: A script to solve the polynomial equation for the mapping of the PWM values with the actual output voltage.
* `ts_calculation`: A script that finds the settling time based on the differential equation for the behavior of the motor and the maximum value of 1.5 V of the motor in use.

### Getting Started

#### Prerequisites

* **PC-side:**
    * C++ compiler (e.g., g++ for Linux/macOS, MSVC for Windows)
    * CMake (for building the C++ project)
    * OpenCV library (for camera operations and image processing)
    * Python 3.x
    * Python packages: `pandas`, `matplotlib`, `keyboard`, `socket` (standard library), `threading` (standard library), `re` (standard library).
* **ESP32-side:**
    * Arduino IDE or PlatformIO
    * ESP32 board package
    * WiFi and WiFiUdp libraries (standard Arduino libraries)

#### Installation and Setup

1.  **PC-side Controller (C++):**
    * Ensure OpenCV is installed and configured for your C++ environment.
    * Navigate to the C++ controller directory (e.g., `final/controller/camera_controller/`).
    * Build using CMake:
        ```bash
        mkdir build
        cd build
        cmake ..
        make # On Linux/macOS
        # On Windows, use `cmake --build .` or open the generated .sln in Visual Studio
        ```
    * The executable will be generated in the `build` directory.

2.  **ESP32 Firmware:**
    * In final/controller/esp32_controller/src
    * Open `main.cpp` in Arduino IDE or PlatformIO.
    * Update `ssid` and `password` with your Wi-Fi network credentials.
    * Update `debugPC_IP` and `ESP32_IP` in `commands_animation.py` and `main_esp.cpp` to match your PC's and ESP32's IP addresses respectively.
    * Upload the code to your ESP32 board.

### Usage

1.  **Run the PC-side Controller:**
    ```bash
    ./build/RobotController # Or the appropriate path/executable name
    ```
    * The application will display a camera feed.
    * **Calibration**: If not already calibrated, follow the on-screen instructions or use the `CameraCalibrator` to click points and calculate the `cmPerPixel` ratio. The calibration data can be saved and loaded from a file.
    * **Target Selection**: Click on the video feed to set a target for the robot.
    * **Video Recording**: You will be prompted to record the session. Enter 'y' or 'n'. If 'y', provide a filename.

2.  **Control the Robot (via `commands_animation.py`):**
    ```bash
    python commands_animation.py
    ```
    * This script will open a plot for real-time RPM visualization and allow sending commands.
    * **Controls:**
        * `w`: Forward
        * `s`: Backward
        * `a`: Difference in motor speeds in order to turn a little to the left
        * `d`: Difference in motor speeds in order to turn a little to the right
        * `space`: Stop Motors
        * `+`: Increase Speed
        * `-`: Decrease Speed
        * `q`: Quit (stops the animation and command loop)
        * `l`: Measure UDP Latency

### How it Works
#### Camera & Marker Detection
The system uses OpenCV for real-time video processing. It converts the camera feed to HSV color space to facilitate color-based marker detection.
* **Macro Controller**: Detects two distinct colored markers (e.g., orange for rear, blue for front) on the robot to determine its orientation and position.
* **Micro Controller**: Detects a single colored marker (e.g., yellowish) and uses contour analysis to find the "tip" of the robot, which is used as the front point.
* The `camera_calibrator` is used to establish the `cmPerPixel` ratio, allowing the system to translate pixel coordinates from the camera feed into real-world centimeter measurements, enabling accurate distance and position calculations for navigation.

#### Robot Movement Control

The `RobotController` base class calculates distances and angles between the robot's current position/orientation and the target.
* **Macro Control**: Based on the angle between the robot's current direction and the target, it issues 'L' (left) or 'R' (right) commands for rotation, and 'C' (continue) for forward movement once aligned. It can also issue 'F' (forward) and 'B' (backward) commands directly.
* **Micro Control**: This controller focuses on reaching the target precisely. If the distance to the target is within a `stopAcceptancePixels` threshold, it issues a 'S' (stop) command. Otherwise, it issues a 'F' (forward) command.
* Commands ('F', 'L', 'R', 'S', '+', '-') are sent via UDP to the ESP32.

#### ESP32 Motor Control

The `main_esp.cpp` firmware on the ESP32 receives UDP commands. It uses these commands to:
* Control two DC motors via PWM (Pulse Width Modulation) using specific pins defined in the code.
* Implement a PID control loop for each motor to maintain a target RPM. The RPM is measured using attached sensors, and the PID controller adjusts the motor voltage (PWM duty cycle) to minimize the error between the target and actual RPM.
* The ESP32 sends debug messages back to the PC, including real-time RPM values for both motors, which are then visualized by `commands_animation.py`.
